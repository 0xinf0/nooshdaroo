// Minimal TLS 1.3 protocol that beats nDPI
// Focus: Make handshake look realistic, don't wrap DATA phase
// Strategy: Fixed-size fields only, no variable-length complexity

@SEGMENT.FORMATS

  // TLS ClientHello - Minimal but realistic
  DEFINE TlsClientHello
    { NAME: content_type     ; TYPE: u8 },       // 0x16 = handshake
    { NAME: version          ; TYPE: u16 },      // 0x0303 = TLS 1.2
    { NAME: record_length    ; TYPE: u16 },      // Total record length
    { NAME: handshake_type   ; TYPE: u8 },       // 0x01 = ClientHello
    { NAME: handshake_length ; TYPE: u24 },      // Handshake message length
    { NAME: client_version   ; TYPE: u16 },      // 0x0303 = TLS 1.2
    { NAME: random           ; TYPE: [u8; 32] }; // Client random (32 bytes)

  // TLS ServerHello - Minimal but realistic
  DEFINE TlsServerHello
    { NAME: content_type     ; TYPE: u8 },       // 0x16 = handshake
    { NAME: version          ; TYPE: u16 },      // 0x0303 = TLS 1.2
    { NAME: record_length    ; TYPE: u16 },      // Record length
    { NAME: handshake_type   ; TYPE: u8 },       // 0x02 = ServerHello
    { NAME: handshake_length ; TYPE: u24 },      // Message length
    { NAME: server_version   ; TYPE: u16 },      // 0x0303
    { NAME: random           ; TYPE: [u8; 32] }; // Server random

  // TLS Application Data - Fixed 1024-byte payload for Noise handshake compatibility
  DEFINE TlsAppData
    { NAME: content_type   ; TYPE: u8 },       // 0x17 for application data
    { NAME: version        ; TYPE: u16 },      // 0x0303 for TLS 1.2 compat
    { NAME: length         ; TYPE: u16 },      // Payload length (fixed at 1024)
    { NAME: payload        ; TYPE: [u8; 1024] }; // Fixed-size payload

@SEGMENT.SEMANTICS

  // ClientHello fixed values
  { FORMAT: TlsClientHello; FIELD: content_type;     SEMANTIC: FIXED_VALUE(0x16) };
  { FORMAT: TlsClientHello; FIELD: version;          SEMANTIC: FIXED_VALUE(0x0303) };
  { FORMAT: TlsClientHello; FIELD: handshake_type;   SEMANTIC: FIXED_VALUE(0x01) };
  { FORMAT: TlsClientHello; FIELD: client_version;   SEMANTIC: FIXED_VALUE(0x0303) };
  { FORMAT: TlsClientHello; FIELD: random;           SEMANTIC: RANDOM };
  { FORMAT: TlsClientHello; FIELD: record_length;    SEMANTIC: LENGTH };
  { FORMAT: TlsClientHello; FIELD: handshake_length; SEMANTIC: LENGTH };

  // ServerHello fixed values
  { FORMAT: TlsServerHello; FIELD: content_type;     SEMANTIC: FIXED_VALUE(0x16) };
  { FORMAT: TlsServerHello; FIELD: version;          SEMANTIC: FIXED_VALUE(0x0303) };
  { FORMAT: TlsServerHello; FIELD: handshake_type;   SEMANTIC: FIXED_VALUE(0x02) };
  { FORMAT: TlsServerHello; FIELD: server_version;   SEMANTIC: FIXED_VALUE(0x0303) };
  { FORMAT: TlsServerHello; FIELD: random;           SEMANTIC: RANDOM };
  { FORMAT: TlsServerHello; FIELD: record_length;    SEMANTIC: LENGTH };
  { FORMAT: TlsServerHello; FIELD: handshake_length; SEMANTIC: LENGTH };

  // Application Data
  { FORMAT: TlsAppData; FIELD: content_type;   SEMANTIC: FIXED_VALUE(0x17) };
  { FORMAT: TlsAppData; FIELD: version;        SEMANTIC: FIXED_VALUE(0x0303) };
  { FORMAT: TlsAppData; FIELD: length;         SEMANTIC: LENGTH };
  { FORMAT: TlsAppData; FIELD: payload;        SEMANTIC: PAYLOAD };

@SEGMENT.SEQUENCE

  // TLS handshake phase (once per connection)
  { ROLE: CLIENT; PHASE: HANDSHAKE; FORMAT: TlsClientHello };
  { ROLE: SERVER; PHASE: HANDSHAKE; FORMAT: TlsServerHello };

  // Bidirectional encrypted data flow
  { ROLE: CLIENT; PHASE: DATA; FORMAT: TlsAppData };
  { ROLE: SERVER; PHASE: DATA; FORMAT: TlsAppData };

@SEGMENT.CRYPTO

  PASSWORD = "nooshdaroo-tls-key";
  CIPHER   = CHACHA20-POLY1305;

  ENCRYPT TlsAppData FROM TlsAppData
    { PTEXT: payload; CTEXT: payload };

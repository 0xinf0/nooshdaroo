# iOS & Android Integration Guide

**Nooshdaroo Mobile SDK Integration**
**Version**: 0.1.0
**Last Updated**: 2025-11-16

---

## Table of Contents

1. [Overview](#overview)
2. [iOS Integration](#ios-integration)
3. [Android Integration](#android-integration)
4. [Shared Mobile Patterns](#shared-mobile-patterns)
5. [Testing & Deployment](#testing--deployment)
6. [Troubleshooting](#troubleshooting)

---

## Overview

This guide covers complete integration of Nooshdaroo into native iOS and Android applications. The Rust core library is exposed through:

- **iOS**: C FFI → Objective-C/Swift bindings
- **Android**: JNI → Kotlin/Java bindings

### Architecture

```
┌─────────────────────────────────────────────────────────────┐
│                    Mobile Application                       │
│  ┌──────────────────┐          ┌──────────────────┐        │
│  │  Swift/Kotlin    │          │  Swift/Kotlin    │        │
│  │  UI Layer        │          │  UI Layer        │        │
│  └────────┬─────────┘          └────────┬─────────┘        │
│           │                              │                  │
│  ┌────────▼─────────┐          ┌────────▼─────────┐        │
│  │  Swift Wrapper   │          │  Kotlin Wrapper  │        │
│  │  (NooshdarooSDK) │          │  (NooshdarooSDK) │        │
│  └────────┬─────────┘          └────────┬─────────┘        │
│           │                              │                  │
│  ┌────────▼─────────┐          ┌────────▼─────────┐        │
│  │  C FFI Bridge    │          │  JNI Bridge      │        │
│  └────────┬─────────┘          └────────┬─────────┘        │
└───────────┼─────────────────────────────┼──────────────────┘
            │                              │
┌───────────▼──────────────────────────────▼──────────────────┐
│              Nooshdaroo Rust Core Library                   │
│  - Noise Protocol Transport (ChaCha20-Poly1305)            │
│  - Protocol Wrapping (PSF Interpreter)                     │
│  - Embedded Server Keys (embedded_keys.rs)                 │
│  - Shape-Shifting Logic                                    │
└─────────────────────────────────────────────────────────────┘
```

### Prerequisites

- **Rust**: 1.70+ with targets:
  - iOS: `aarch64-apple-ios`, `x86_64-apple-ios` (simulator)
  - Android: `aarch64-linux-android`, `armv7-linux-androideabi`, `x86_64-linux-android`
- **iOS Development**: Xcode 15+, macOS 13+
- **Android Development**: Android Studio 2023+, Android SDK 33+
- **Build Tools**: `cbindgen`, `cargo-ndk`

---

## iOS Integration

### Step 1: Build Rust Library for iOS

#### Install iOS Targets

```bash
rustup target add aarch64-apple-ios
rustup target add x86_64-apple-ios  # For simulator
rustup target add aarch64-apple-ios-sim  # For M1/M2 simulators
```

#### Build Script (`build_ios.sh`)

Create a build script in the project root:

```bash
#!/bin/bash
# build_ios.sh - Build Nooshdaroo for iOS

set -e

# Configuration
LIB_NAME="libnooshdaroo"
PROJECT_DIR="$(pwd)"
BUILD_DIR="${PROJECT_DIR}/target/ios"

# Embed production server keys at build time
export NOOSHDAROO_PRIMARY_KEY="YOUR_PRIMARY_KEY_HERE"
export NOOSHDAROO_PRIMARY_SERVER="vpn.example.com:8443"

echo "Building for iOS targets..."

# Build for device (ARM64)
cargo build --release --target aarch64-apple-ios

# Build for simulator (x86_64 Intel Macs)
cargo build --release --target x86_64-apple-ios

# Build for simulator (ARM64 M1/M2 Macs)
cargo build --release --target aarch64-apple-ios-sim

# Create universal simulator library
mkdir -p "${BUILD_DIR}/simulator"
lipo -create \
    "target/x86_64-apple-ios/release/${LIB_NAME}.a" \
    "target/aarch64-apple-ios-sim/release/${LIB_NAME}.a" \
    -output "${BUILD_DIR}/simulator/${LIB_NAME}.a"

# Copy device library
mkdir -p "${BUILD_DIR}/device"
cp "target/aarch64-apple-ios/release/${LIB_NAME}.a" \
   "${BUILD_DIR}/device/${LIB_NAME}.a"

echo "iOS libraries built successfully:"
echo "  Device: ${BUILD_DIR}/device/${LIB_NAME}.a"
echo "  Simulator: ${BUILD_DIR}/simulator/${LIB_NAME}.a"
```

Make it executable:

```bash
chmod +x build_ios.sh
./build_ios.sh
```

### Step 2: Generate C Headers

Install `cbindgen`:

```bash
cargo install cbindgen
```

Create `cbindgen.toml`:

```toml
# cbindgen.toml
language = "C"
include_guard = "NOOSHDAROO_H"
pragma_once = true
autogen_warning = "/* Warning: This file is auto-generated by cbindgen. Do not edit manually. */"

[export]
include = ["NooshdarooClient", "NooshdarooConfig", "NooshdarooError"]

[export.rename]
"NooshdarooClient" = "NooshdarooClient"
"NooshdarooConfig" = "NooshdarooConfig"

[parse]
parse_deps = false
include = ["nooshdaroo"]
```

Add FFI bindings to `src/mobile.rs`:

```rust
// src/mobile.rs - Extend with C FFI exports

use std::ffi::{CStr, CString};
use std::os::raw::c_char;
use crate::{NooshdarooConfig, NooshdarooClient, ProtocolId};
use crate::embedded_keys::{get_server_config, ServerEndpoint};

/// C-compatible error codes
#[repr(C)]
pub enum NooshdarooErrorCode {
    Success = 0,
    InvalidConfig = 1,
    ConnectionFailed = 2,
    ProtocolError = 3,
    Unknown = 99,
}

/// Opaque handle to NooshdarooClient
pub struct NooshdarooHandle {
    client: NooshdarooClient,
}

/// Create a new Nooshdaroo client with protocol and server endpoint
///
/// # Parameters
/// - `protocol`: Protocol name (e.g., "https-google", "dns-google")
/// - `endpoint`: Server endpoint (0=Primary, 1=Fallback, 2=EuropeWest, etc.)
/// - `local_port`: Local SOCKS5 port (e.g., 1080)
///
/// # Returns
/// - Opaque pointer to NooshdarooHandle on success, NULL on failure
///
/// # Safety
/// - Caller must call `nooshdaroo_free()` to release resources
/// - `protocol` must be a valid null-terminated C string
#[no_mangle]
pub unsafe extern "C" fn nooshdaroo_create(
    protocol: *const c_char,
    endpoint: u8,
    local_port: u16,
) -> *mut NooshdarooHandle {
    if protocol.is_null() {
        return std::ptr::null_mut();
    }

    let protocol_str = match CStr::from_ptr(protocol).to_str() {
        Ok(s) => s,
        Err(_) => return std::ptr::null_mut(),
    };

    let server_endpoint = match endpoint {
        0 => ServerEndpoint::Primary,
        1 => ServerEndpoint::Fallback,
        2 => ServerEndpoint::EuropeWest,
        3 => ServerEndpoint::AsiaPacific,
        4 => ServerEndpoint::NorthAmericaEast,
        5 => ServerEndpoint::Development,
        _ => return std::ptr::null_mut(),
    };

    let server_config = get_server_config(server_endpoint);

    let mut config = NooshdarooConfig::default();
    config.local_bind = format!("127.0.0.1:{}", local_port);
    config.server_address = server_config.address.to_string();
    config.server_public_key = Some(server_config.public_key.to_string());

    match NooshdarooClient::new(config) {
        Ok(client) => Box::into_raw(Box::new(NooshdarooHandle { client })),
        Err(_) => std::ptr::null_mut(),
    }
}

/// Start the Nooshdaroo client connection
///
/// # Safety
/// - `handle` must be a valid pointer from `nooshdaroo_create()`
#[no_mangle]
pub unsafe extern "C" fn nooshdaroo_start(handle: *mut NooshdarooHandle) -> NooshdarooErrorCode {
    if handle.is_null() {
        return NooshdarooErrorCode::InvalidConfig;
    }

    // In actual implementation, spawn async runtime and start client
    // This is a simplified version
    NooshdarooErrorCode::Success
}

/// Stop the Nooshdaroo client connection
///
/// # Safety
/// - `handle` must be a valid pointer from `nooshdaroo_create()`
#[no_mangle]
pub unsafe extern "C" fn nooshdaroo_stop(handle: *mut NooshdarooHandle) -> NooshdarooErrorCode {
    if handle.is_null() {
        return NooshdarooErrorCode::InvalidConfig;
    }

    // Stop client connections
    NooshdarooErrorCode::Success
}

/// Free Nooshdaroo client handle
///
/// # Safety
/// - `handle` must be a valid pointer from `nooshdaroo_create()`
/// - Must only be called once per handle
#[no_mangle]
pub unsafe extern "C" fn nooshdaroo_free(handle: *mut NooshdarooHandle) {
    if !handle.is_null() {
        let _ = Box::from_raw(handle);
    }
}

/// Get current protocol name
///
/// # Safety
/// - `handle` must be valid
/// - Caller must free returned string with `nooshdaroo_free_string()`
#[no_mangle]
pub unsafe extern "C" fn nooshdaroo_get_protocol(handle: *mut NooshdarooHandle) -> *mut c_char {
    if handle.is_null() {
        return std::ptr::null_mut();
    }

    // In real implementation, get from client
    let protocol_name = "https-google";

    match CString::new(protocol_name) {
        Ok(s) => s.into_raw(),
        Err(_) => std::ptr::null_mut(),
    }
}

/// Free string returned by Nooshdaroo functions
///
/// # Safety
/// - `s` must be from a Nooshdaroo function that returns strings
#[no_mangle]
pub unsafe extern "C" fn nooshdaroo_free_string(s: *mut c_char) {
    if !s.is_null() {
        let _ = CString::from_raw(s);
    }
}
```

Generate header:

```bash
cbindgen --config cbindgen.toml --crate nooshdaroo --output include/nooshdaroo.h
```

### Step 3: Xcode Project Setup

#### Create XCFramework

Create `create_xcframework.sh`:

```bash
#!/bin/bash
# create_xcframework.sh - Package iOS libraries as XCFramework

set -e

BUILD_DIR="target/ios"
XCFRAMEWORK_DIR="NooshdarooSDK.xcframework"

rm -rf "${XCFRAMEWORK_DIR}"

xcodebuild -create-xcframework \
    -library "${BUILD_DIR}/device/libnooshdaroo.a" \
    -headers "include/" \
    -library "${BUILD_DIR}/simulator/libnooshdaroo.a" \
    -headers "include/" \
    -output "${XCFRAMEWORK_DIR}"

echo "XCFramework created: ${XCFRAMEWORK_DIR}"
```

Run it:

```bash
chmod +x create_xcframework.sh
./create_xcframework.sh
```

#### Add to Xcode Project

1. Drag `NooshdarooSDK.xcframework` into your Xcode project
2. Select "Copy items if needed"
3. Add to "Frameworks, Libraries, and Embedded Content"
4. Set to "Embed & Sign"

### Step 4: Swift Wrapper

Create `NooshdarooSDK.swift`:

```swift
// NooshdarooSDK.swift
import Foundation
import Network

/// Nooshdaroo protocol options
public enum NooshdarooProtocol: String {
    case https = "https"
    case httpsGoogle = "https-google"
    case dns = "dns"
    case dnsGoogle = "dns-google"
    case ssh = "ssh"
}

/// Server endpoint regions
public enum ServerEndpoint: UInt8 {
    case primary = 0
    case fallback = 1
    case europeWest = 2
    case asiaPacific = 3
    case northAmericaEast = 4
    case development = 5
}

/// Nooshdaroo client errors
public enum NooshdarooError: Error {
    case invalidConfiguration
    case connectionFailed
    case protocolError
    case unknown

    init(code: NooshdarooErrorCode) {
        switch code {
        case Success:
            self = .unknown  // Shouldn't happen
        case InvalidConfig:
            self = .invalidConfiguration
        case ConnectionFailed:
            self = .connectionFailed
        case ProtocolError:
            self = .protocolError
        case Unknown:
            self = .unknown
        @unknown default:
            self = .unknown
        }
    }
}

/// Nooshdaroo VPN client
public class NooshdarooClient {
    private var handle: OpaquePointer?

    /// Initialize Nooshdaroo client
    ///
    /// - Parameters:
    ///   - protocol: Protocol to emulate
    ///   - endpoint: Server endpoint region
    ///   - localPort: Local SOCKS5 proxy port
    public init(protocol: NooshdarooProtocol,
                endpoint: ServerEndpoint = .primary,
                localPort: UInt16 = 1080) throws {

        let protocolCString = `protocol`.rawValue.cString(using: .utf8)!

        self.handle = protocolCString.withUnsafeBufferPointer { buffer in
            nooshdaroo_create(buffer.baseAddress, endpoint.rawValue, localPort)
        }

        guard handle != nil else {
            throw NooshdarooError.invalidConfiguration
        }
    }

    deinit {
        if let handle = handle {
            nooshdaroo_free(handle)
        }
    }

    /// Start VPN connection
    public func start() throws {
        guard let handle = handle else {
            throw NooshdarooError.invalidConfiguration
        }

        let result = nooshdaroo_start(handle)

        if result != Success {
            throw NooshdarooError(code: result)
        }
    }

    /// Stop VPN connection
    public func stop() throws {
        guard let handle = handle else {
            throw NooshdarooError.invalidConfiguration
        }

        let result = nooshdaroo_stop(handle)

        if result != Success {
            throw NooshdarooError(code: result)
        }
    }

    /// Get current protocol name
    public func currentProtocol() -> String? {
        guard let handle = handle else { return nil }

        guard let cString = nooshdaroo_get_protocol(handle) else {
            return nil
        }

        defer {
            nooshdaroo_free_string(cString)
        }

        return String(cString: cString)
    }
}
```

### Step 5: Network Extension Implementation

#### Configure Entitlements

Add to your app's entitlements file:

```xml
<!-- YourApp.entitlements -->
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
    <key>com.apple.developer.networking.networkextension</key>
    <array>
        <string>packet-tunnel-provider</string>
    </array>
</dict>
</plist>
```

#### Create Network Extension Target

1. In Xcode: File → New → Target → Network Extension
2. Choose "Packet Tunnel Provider"
3. Name it "NooshdarooTunnel"

#### Implement PacketTunnelProvider

```swift
// PacketTunnelProvider.swift
import NetworkExtension
import NooshdarooSDK

class PacketTunnelProvider: NEPacketTunnelProvider {

    private var nooshdarooClient: NooshdarooClient?

    override func startTunnel(options: [String : NSObject]?,
                            completionHandler: @escaping (Error?) -> Void) {

        // Read configuration from options
        let protocolName = (options?["protocol"] as? String) ?? "https-google"
        let endpointRaw = (options?["endpoint"] as? NSNumber)?.uint8Value ?? 0

        let protocolEnum = NooshdarooProtocol(rawValue: protocolName) ?? .httpsGoogle
        let endpoint = ServerEndpoint(rawValue: endpointRaw) ?? .primary

        do {
            // Initialize Nooshdaroo client
            nooshdarooClient = try NooshdarooClient(
                protocol: protocolEnum,
                endpoint: endpoint,
                localPort: 1080
            )

            // Configure tunnel network settings
            let tunnelNetworkSettings = NEPacketTunnelNetworkSettings(tunnelRemoteAddress: "10.8.0.1")

            // IPv4 settings
            let ipv4Settings = NEIPv4Settings(addresses: ["10.8.0.2"],
                                             subnetMasks: ["255.255.255.0"])
            ipv4Settings.includedRoutes = [NEIPv4Route.default()]
            tunnelNetworkSettings.ipv4Settings = ipv4Settings

            // DNS settings (route through tunnel)
            let dnsSettings = NEDNSSettings(servers: ["8.8.8.8", "8.8.4.4"])
            tunnelNetworkSettings.dnsSettings = dnsSettings

            // MTU
            tunnelNetworkSettings.mtu = 1500

            // Apply settings
            setTunnelNetworkSettings(tunnelNetworkSettings) { error in
                if let error = error {
                    completionHandler(error)
                    return
                }

                // Start Nooshdaroo client
                do {
                    try self.nooshdarooClient?.start()
                    completionHandler(nil)
                } catch {
                    completionHandler(error)
                }
            }

        } catch {
            completionHandler(error)
        }
    }

    override func stopTunnel(with reason: NEProviderStopReason,
                           completionHandler: @escaping () -> Void) {

        do {
            try nooshdarooClient?.stop()
        } catch {
            NSLog("Error stopping Nooshdaroo: \(error)")
        }

        completionHandler()
    }

    override func handleAppMessage(_ messageData: Data,
                                  completionHandler: ((Data?) -> Void)?) {
        // Handle IPC from main app if needed
        completionHandler?(nil)
    }
}
```

### Step 6: iOS App Usage Example

```swift
// ViewController.swift
import UIKit
import NetworkExtension

class ViewController: UIViewController {

    private var vpnManager: NETunnelProviderManager?

    override func viewDidLoad() {
        super.viewDidLoad()
        loadVPNConfiguration()
    }

    func loadVPNConfiguration() {
        NETunnelProviderManager.loadAllFromPreferences { managers, error in
            if let error = error {
                print("Error loading VPN config: \(error)")
                return
            }

            if let manager = managers?.first {
                self.vpnManager = manager
            } else {
                self.createVPNConfiguration()
            }
        }
    }

    func createVPNConfiguration() {
        let manager = NETunnelProviderManager()
        manager.localizedDescription = "Nooshdaroo VPN"

        let proto = NETunnelProviderProtocol()
        proto.providerBundleIdentifier = "com.yourcompany.yourapp.NooshdarooTunnel"
        proto.serverAddress = "vpn.example.com"

        // Pass configuration options
        proto.providerConfiguration = [
            "protocol": "https-google",
            "endpoint": NSNumber(value: 0)  // Primary
        ]

        manager.protocolConfiguration = proto
        manager.isEnabled = true

        manager.saveToPreferences { error in
            if let error = error {
                print("Error saving VPN config: \(error)")
                return
            }

            self.vpnManager = manager
        }
    }

    @IBAction func connectButtonTapped(_ sender: UIButton) {
        guard let manager = vpnManager else { return }

        do {
            try manager.connection.startVPNTunnel()
        } catch {
            print("Error starting VPN: \(error)")
        }
    }

    @IBAction func disconnectButtonTapped(_ sender: UIButton) {
        vpnManager?.connection.stopVPNTunnel()
    }
}
```

---

## Android Integration

### Step 1: Build Rust Library for Android

#### Install Android Targets

```bash
rustup target add aarch64-linux-android   # ARM64
rustup target add armv7-linux-androideabi # ARMv7
rustup target add x86_64-linux-android    # x86_64 emulator
```

#### Install cargo-ndk

```bash
cargo install cargo-ndk
```

#### Set Android NDK Path

```bash
export ANDROID_NDK_HOME="$HOME/Library/Android/sdk/ndk/25.2.9519653"
```

#### Build Script (`build_android.sh`)

```bash
#!/bin/bash
# build_android.sh - Build Nooshdaroo for Android

set -e

# Configuration
export ANDROID_NDK_HOME="${ANDROID_NDK_HOME:-$HOME/Library/Android/sdk/ndk/25.2.9519653}"

# Embed production server keys
export NOOSHDAROO_PRIMARY_KEY="YOUR_PRIMARY_KEY_HERE"
export NOOSHDAROO_PRIMARY_SERVER="vpn.example.com:8443"

echo "Building for Android targets..."

# Build for all Android architectures
cargo ndk \
    --target aarch64-linux-android \
    --target armv7-linux-androideabi \
    --target x86_64-linux-android \
    --platform 29 \
    -- build --release

# Copy to jniLibs
JNI_DIR="android/app/src/main/jniLibs"
mkdir -p "${JNI_DIR}"/{arm64-v8a,armeabi-v7a,x86_64}

cp target/aarch64-linux-android/release/libnooshdaroo.so \
   "${JNI_DIR}/arm64-v8a/"

cp target/armv7-linux-androideabi/release/libnooshdaroo.so \
   "${JNI_DIR}/armeabi-v7a/"

cp target/x86_64-linux-android/release/libnooshdaroo.so \
   "${JNI_DIR}/x86_64/"

echo "Android libraries built and copied to ${JNI_DIR}"
```

Run it:

```bash
chmod +x build_android.sh
./build_android.sh
```

### Step 2: JNI Bindings

Create `src/jni_bindings.rs`:

```rust
// src/jni_bindings.rs - JNI exports for Android

#![cfg(target_os = "android")]

use jni::JNIEnv;
use jni::objects::{JClass, JString};
use jni::sys::{jlong, jint, jstring};
use std::ptr;
use crate::{NooshdarooConfig, NooshdarooClient};
use crate::embedded_keys::{get_server_config, ServerEndpoint};

/// Create Nooshdaroo client
///
/// # Parameters
/// - `protocol`: Protocol name (e.g., "https-google")
/// - `endpoint`: Server endpoint (0-5)
/// - `localPort`: Local SOCKS5 port
///
/// # Returns
/// - Pointer to NooshdarooClient as jlong
#[no_mangle]
pub extern "C" fn Java_com_nooshdaroo_sdk_NooshdarooClient_nativeCreate(
    env: JNIEnv,
    _class: JClass,
    protocol: JString,
    endpoint: jint,
    local_port: jint,
) -> jlong {
    let protocol_str: String = match env.get_string(protocol) {
        Ok(s) => s.into(),
        Err(_) => return 0,
    };

    let server_endpoint = match endpoint {
        0 => ServerEndpoint::Primary,
        1 => ServerEndpoint::Fallback,
        2 => ServerEndpoint::EuropeWest,
        3 => ServerEndpoint::AsiaPacific,
        4 => ServerEndpoint::NorthAmericaEast,
        5 => ServerEndpoint::Development,
        _ => return 0,
    };

    let server_config = get_server_config(server_endpoint);

    let mut config = NooshdarooConfig::default();
    config.local_bind = format!("127.0.0.1:{}", local_port);
    config.server_address = server_config.address.to_string();
    config.server_public_key = Some(server_config.public_key.to_string());

    match NooshdarooClient::new(config) {
        Ok(client) => Box::into_raw(Box::new(client)) as jlong,
        Err(_) => 0,
    }
}

/// Start client connection
#[no_mangle]
pub extern "C" fn Java_com_nooshdaroo_sdk_NooshdarooClient_nativeStart(
    _env: JNIEnv,
    _class: JClass,
    handle: jlong,
) -> jint {
    if handle == 0 {
        return -1;
    }

    // In real implementation, start async runtime
    0  // Success
}

/// Stop client connection
#[no_mangle]
pub extern "C" fn Java_com_nooshdaroo_sdk_NooshdarooClient_nativeStop(
    _env: JNIEnv,
    _class: JClass,
    handle: jlong,
) -> jint {
    if handle == 0 {
        return -1;
    }

    // Stop client
    0  // Success
}

/// Free client handle
#[no_mangle]
pub extern "C" fn Java_com_nooshdaroo_sdk_NooshdarooClient_nativeFree(
    _env: JNIEnv,
    _class: JClass,
    handle: jlong,
) {
    if handle != 0 {
        unsafe {
            let _ = Box::from_raw(handle as *mut NooshdarooClient);
        }
    }
}

/// Get current protocol
#[no_mangle]
pub extern "C" fn Java_com_nooshdaroo_sdk_NooshdarooClient_nativeGetProtocol(
    env: JNIEnv,
    _class: JClass,
    handle: jlong,
) -> jstring {
    if handle == 0 {
        return ptr::null_mut();
    }

    // In real implementation, get from client
    let protocol = "https-google";

    match env.new_string(protocol) {
        Ok(s) => s.into_raw(),
        Err(_) => ptr::null_mut(),
    }
}
```

Add to `src/lib.rs`:

```rust
#[cfg(target_os = "android")]
pub mod jni_bindings;
```

### Step 3: Android Studio Project Setup

#### Project Structure

```
android/
├── app/
│   ├── build.gradle
│   ├── src/
│   │   └── main/
│   │       ├── AndroidManifest.xml
│   │       ├── java/com/nooshdaroo/sdk/
│   │       │   ├── NooshdarooClient.kt
│   │       │   ├── NooshdarooVpnService.kt
│   │       │   └── Protocol.kt
│   │       └── jniLibs/
│   │           ├── arm64-v8a/libnooshdaroo.so
│   │           ├── armeabi-v7a/libnooshdaroo.so
│   │           └── x86_64/libnooshdaroo.so
└── build.gradle
```

#### app/build.gradle

```gradle
plugins {
    id 'com.android.application'
    id 'org.jetbrains.kotlin.android'
}

android {
    namespace 'com.nooshdaroo.vpn'
    compileSdk 34

    defaultConfig {
        applicationId "com.nooshdaroo.vpn"
        minSdk 29
        targetSdk 34
        versionCode 1
        versionName "1.0"
    }

    buildTypes {
        release {
            minifyEnabled false
            proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'
        }
    }

    compileOptions {
        sourceCompatibility JavaVersion.VERSION_17
        targetCompatibility JavaVersion.VERSION_17
    }

    kotlinOptions {
        jvmTarget = '17'
    }
}

dependencies {
    implementation 'androidx.core:core-ktx:1.12.0'
    implementation 'androidx.appcompat:appcompat:1.6.1'
    implementation 'com.google.android.material:material:1.11.0'
}
```

### Step 4: Kotlin Wrapper

#### NooshdarooClient.kt

```kotlin
// NooshdarooClient.kt
package com.nooshdaroo.sdk

enum class Protocol(val value: String) {
    HTTPS("https"),
    HTTPS_GOOGLE("https-google"),
    DNS("dns"),
    DNS_GOOGLE("dns-google"),
    SSH("ssh")
}

enum class ServerEndpoint(val value: Int) {
    PRIMARY(0),
    FALLBACK(1),
    EUROPE_WEST(2),
    ASIA_PACIFIC(3),
    NORTH_AMERICA_EAST(4),
    DEVELOPMENT(5)
}

class NooshdarooException(message: String) : Exception(message)

class NooshdarooClient(
    protocol: Protocol,
    endpoint: ServerEndpoint = ServerEndpoint.PRIMARY,
    localPort: Int = 1080
) {
    private var nativeHandle: Long = 0

    init {
        System.loadLibrary("nooshdaroo")

        nativeHandle = nativeCreate(protocol.value, endpoint.value, localPort)

        if (nativeHandle == 0L) {
            throw NooshdarooException("Failed to create Nooshdaroo client")
        }
    }

    fun start() {
        val result = nativeStart(nativeHandle)
        if (result != 0) {
            throw NooshdarooException("Failed to start client")
        }
    }

    fun stop() {
        val result = nativeStop(nativeHandle)
        if (result != 0) {
            throw NooshdarooException("Failed to stop client")
        }
    }

    fun getCurrentProtocol(): String? {
        return nativeGetProtocol(nativeHandle)
    }

    fun close() {
        if (nativeHandle != 0L) {
            nativeFree(nativeHandle)
            nativeHandle = 0
        }
    }

    protected fun finalize() {
        close()
    }

    // Native methods
    private external fun nativeCreate(protocol: String, endpoint: Int, localPort: Int): Long
    private external fun nativeStart(handle: Long): Int
    private external fun nativeStop(handle: Long): Int
    private external fun nativeFree(handle: Long)
    private external fun nativeGetProtocol(handle: Long): String?
}
```

### Step 5: VPN Service Implementation

#### AndroidManifest.xml

```xml
<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android">

    <uses-permission android:name="android.permission.INTERNET" />
    <uses-permission android:name="android.permission.ACCESS_NETWORK_STATE" />
    <uses-permission android:name="android.permission.FOREGROUND_SERVICE" />

    <application
        android:allowBackup="true"
        android:icon="@mipmap/ic_launcher"
        android:label="@string/app_name"
        android:theme="@style/Theme.NooshdarooVPN">

        <activity
            android:name=".MainActivity"
            android:exported="true">
            <intent-filter>
                <action android:name="android.intent.action.MAIN" />
                <category android:name="android.intent.category.LAUNCHER" />
            </intent-filter>
        </activity>

        <service
            android:name=".NooshdarooVpnService"
            android:permission="android.permission.BIND_VPN_SERVICE"
            android:exported="false">
            <intent-filter>
                <action android:name="android.net.VpnService" />
            </intent-filter>
        </service>

    </application>

</manifest>
```

#### NooshdarooVpnService.kt

```kotlin
// NooshdarooVpnService.kt
package com.nooshdaroo.vpn

import android.app.Notification
import android.app.NotificationChannel
import android.app.NotificationManager
import android.app.PendingIntent
import android.content.Intent
import android.net.VpnService
import android.os.Build
import android.os.ParcelFileDescriptor
import androidx.core.app.NotificationCompat
import com.nooshdaroo.sdk.NooshdarooClient
import com.nooshdaroo.sdk.Protocol
import com.nooshdaroo.sdk.ServerEndpoint

class NooshdarooVpnService : VpnService() {

    private var vpnInterface: ParcelFileDescriptor? = null
    private var nooshdarooClient: NooshdarooClient? = null

    companion object {
        const val ACTION_CONNECT = "com.nooshdaroo.vpn.CONNECT"
        const val ACTION_DISCONNECT = "com.nooshdaroo.vpn.DISCONNECT"
        const val EXTRA_PROTOCOL = "protocol"
        const val EXTRA_ENDPOINT = "endpoint"
        const val NOTIFICATION_ID = 1
        const val CHANNEL_ID = "NooshdarooVPN"
    }

    override fun onStartCommand(intent: Intent?, flags: Int, startId: Int): Int {
        when (intent?.action) {
            ACTION_CONNECT -> {
                val protocolName = intent.getStringExtra(EXTRA_PROTOCOL) ?: "https-google"
                val endpointValue = intent.getIntExtra(EXTRA_ENDPOINT, 0)

                val protocol = Protocol.valueOf(protocolName.uppercase().replace("-", "_"))
                val endpoint = ServerEndpoint.values()[endpointValue]

                connect(protocol, endpoint)
            }
            ACTION_DISCONNECT -> {
                disconnect()
            }
        }

        return START_STICKY
    }

    private fun connect(protocol: Protocol, endpoint: ServerEndpoint) {
        try {
            // Create Nooshdaroo client
            nooshdarooClient = NooshdarooClient(
                protocol = protocol,
                endpoint = endpoint,
                localPort = 1080
            )

            // Configure VPN interface
            vpnInterface = Builder()
                .setSession("Nooshdaroo VPN")
                .addAddress("10.8.0.2", 24)
                .addRoute("0.0.0.0", 0)  // Route all traffic
                .addDnsServer("8.8.8.8")
                .addDnsServer("8.8.4.4")
                .setMtu(1500)
                .establish()

            if (vpnInterface == null) {
                throw Exception("Failed to establish VPN interface")
            }

            // Start Nooshdaroo client
            nooshdarooClient?.start()

            // Start foreground service with notification
            startForeground(NOTIFICATION_ID, createNotification("Connected"))

        } catch (e: Exception) {
            disconnect()
            stopSelf()
        }
    }

    private fun disconnect() {
        nooshdarooClient?.stop()
        nooshdarooClient?.close()
        nooshdarooClient = null

        vpnInterface?.close()
        vpnInterface = null

        stopForeground(true)
        stopSelf()
    }

    private fun createNotification(status: String): Notification {
        createNotificationChannel()

        val pendingIntent = PendingIntent.getActivity(
            this,
            0,
            Intent(this, MainActivity::class.java),
            PendingIntent.FLAG_IMMUTABLE
        )

        return NotificationCompat.Builder(this, CHANNEL_ID)
            .setContentTitle("Nooshdaroo VPN")
            .setContentText(status)
            .setSmallIcon(android.R.drawable.ic_dialog_info)
            .setContentIntent(pendingIntent)
            .setOngoing(true)
            .build()
    }

    private fun createNotificationChannel() {
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
            val channel = NotificationChannel(
                CHANNEL_ID,
                "Nooshdaroo VPN Service",
                NotificationManager.IMPORTANCE_LOW
            )
            val manager = getSystemService(NotificationManager::class.java)
            manager?.createNotificationChannel(channel)
        }
    }

    override fun onDestroy() {
        disconnect()
        super.onDestroy()
    }
}
```

### Step 6: Android App Usage Example

#### MainActivity.kt

```kotlin
// MainActivity.kt
package com.nooshdaroo.vpn

import android.content.Intent
import android.net.VpnService
import android.os.Bundle
import android.widget.Button
import android.widget.Toast
import androidx.activity.result.contract.ActivityResultContracts
import androidx.appcompat.app.AppCompatActivity

class MainActivity : AppCompatActivity() {

    private val vpnPermissionLauncher = registerForActivityResult(
        ActivityResultContracts.StartActivityForResult()
    ) { result ->
        if (result.resultCode == RESULT_OK) {
            startVpn()
        } else {
            Toast.makeText(this, "VPN permission denied", Toast.LENGTH_SHORT).show()
        }
    }

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)

        findViewById<Button>(R.id.buttonConnect).setOnClickListener {
            requestVpnPermission()
        }

        findViewById<Button>(R.id.buttonDisconnect).setOnClickListener {
            stopVpn()
        }
    }

    private fun requestVpnPermission() {
        val intent = VpnService.prepare(this)
        if (intent != null) {
            vpnPermissionLauncher.launch(intent)
        } else {
            startVpn()
        }
    }

    private fun startVpn() {
        val intent = Intent(this, NooshdarooVpnService::class.java).apply {
            action = NooshdarooVpnService.ACTION_CONNECT
            putExtra(NooshdarooVpnService.EXTRA_PROTOCOL, "https-google")
            putExtra(NooshdarooVpnService.EXTRA_ENDPOINT, 0)  // Primary
        }
        startService(intent)
        Toast.makeText(this, "VPN connecting...", Toast.LENGTH_SHORT).show()
    }

    private fun stopVpn() {
        val intent = Intent(this, NooshdarooVpnService::class.java).apply {
            action = NooshdarooVpnService.ACTION_DISCONNECT
        }
        startService(intent)
        Toast.makeText(this, "VPN disconnecting...", Toast.LENGTH_SHORT).show()
    }
}
```

---

## Shared Mobile Patterns

### Server Key Management

Both platforms use the embedded server keys from `src/embedded_keys.rs`:

```rust
// Built with environment variables
export NOOSHDAROO_PRIMARY_KEY="ynXDvH7v8yK+tKJPqz9j8F5GqL2QF3r4E8f9cB7J2zM="
export NOOSHDAROO_PRIMARY_SERVER="vpn.example.com:8443"
cargo build --release --target <platform>
```

### Battery Optimization

#### iOS: Background Task Handling

```swift
// Use URLSession background configuration
let config = URLSessionConfiguration.background(withIdentifier: "com.nooshdaroo.vpn")
config.sessionSendsLaunchEvents = true

// Request background time when app enters background
let taskID = UIApplication.shared.beginBackgroundTask {
    // Cleanup
}
```

#### Android: Doze Mode Handling

```kotlin
// Request battery optimization exemption
val intent = Intent(Settings.ACTION_REQUEST_IGNORE_BATTERY_OPTIMIZATIONS)
intent.data = Uri.parse("package:$packageName")
startActivity(intent)

// Use WorkManager for scheduled tasks
val workRequest = PeriodicWorkRequestBuilder<VpnHealthCheckWorker>(15, TimeUnit.MINUTES)
    .build()
WorkManager.getInstance(context).enqueue(workRequest)
```

### Network Switching (WiFi ↔ LTE)

#### iOS: Network Path Monitor

```swift
import Network

let monitor = NWPathMonitor()
monitor.pathUpdateHandler = { path in
    if path.status == .satisfied {
        // Reconnect VPN with new network
        self.reconnectVPN()
    }
}
monitor.start(queue: DispatchQueue.global())
```

#### Android: Network Callback

```kotlin
val connectivityManager = getSystemService(ConnectivityManager::class.java)
val networkCallback = object : ConnectivityManager.NetworkCallback() {
    override fun onAvailable(network: Network) {
        // Reconnect VPN
        reconnectVPN()
    }
}
connectivityManager.registerDefaultNetworkCallback(networkCallback)
```

---

## Testing & Deployment

### iOS Testing

#### Simulator Testing

```bash
# Build for simulator
./build_ios.sh

# Run in Xcode simulator
# Note: VPN features are limited in simulator
```

#### Physical Device Testing

1. Connect iPhone/iPad via USB
2. Enable Developer Mode (iOS 16+)
3. Select device in Xcode
4. Build and run (Cmd+R)
5. Trust developer certificate in Settings

### Android Testing

#### Emulator Testing

```bash
# Build for x86_64
./build_android.sh

# Start emulator
emulator -avd Pixel_7_API_34

# Install APK
./gradlew installDebug
```

#### Physical Device Testing

```bash
# Enable USB debugging on device
# Settings → About Phone → Tap Build Number 7 times
# Settings → Developer Options → USB Debugging

# Connect via USB
adb devices

# Install
./gradlew installDebug
```

### Performance Testing

#### Bandwidth Test

```bash
# On client
iperf3 -c <destination_server> -p 5201

# Expected throughput:
# - WiFi: 500-800 Mbps
# - LTE: 50-100 Mbps
# - 5G: 200-500 Mbps
```

#### Latency Test

```bash
# Measure latency overhead
ping <destination_ip>

# Expected overhead: <5ms
```

#### Battery Test

- Run VPN for 6 hours
- Monitor battery drain
- Target: <5% per hour with moderate usage

### App Store Submission

#### iOS App Store

1. **Prepare Binary**:
   ```bash
   ./build_ios.sh
   ```

2. **Archive in Xcode**:
   - Product → Archive
   - Distribute App → App Store Connect
   - Upload

3. **App Store Connect**:
   - Fill app metadata
   - Upload screenshots (6.7", 6.5", 5.5")
   - Privacy policy URL (required for VPN apps)
   - Export compliance: Declare encryption usage

4. **Review Notes**:
   ```
   This app uses encryption for VPN functionality via the
   Noise Protocol Framework (ChaCha20-Poly1305). Server keys
   are embedded at compile time for certificate pinning.

   Test Account: test@example.com / TestPass123
   Test Server: vpn-test.example.com:8443
   ```

#### Google Play Store

1. **Prepare AAB**:
   ```bash
   ./build_android.sh
   ./gradlew bundleRelease
   ```

2. **Sign with Release Key**:
   ```bash
   jarsigner -verbose -sigalg SHA256withRSA -digestalg SHA-256 \
     -keystore release.keystore \
     app/build/outputs/bundle/release/app-release.aab \
     release-key
   ```

3. **Google Play Console**:
   - Upload AAB
   - Fill store listing
   - Screenshots (phone, tablet, TV)
   - Privacy policy
   - Data safety form

4. **VPN Disclosure**:
   - Check "This app is a VPN"
   - Provide privacy policy explaining data handling
   - Explain encryption usage

---

## Troubleshooting

### iOS Issues

#### Issue: "dyld: Library not loaded"

**Solution**: Ensure XCFramework is embedded and signed:
1. Project Settings → General → Frameworks, Libraries, and Embedded Content
2. Set to "Embed & Sign"

#### Issue: Network Extension crashes on start

**Solution**: Check entitlements and provisioning profile:
```bash
# Verify entitlements
security cms -D -i YourApp.mobileprovision | grep -A 20 Entitlements
```

#### Issue: VPN connects but no traffic flows

**Solution**: Check routing configuration in `PacketTunnelProvider`:
```swift
ipv4Settings.includedRoutes = [NEIPv4Route.default()]
```

### Android Issues

#### Issue: "UnsatisfiedLinkError: dlopen failed"

**Solution**: Verify JNI library architecture matches device:
```bash
# Check APK contents
unzip -l app-debug.apk | grep libnooshdaroo.so

# Should see:
# lib/arm64-v8a/libnooshdaroo.so
# lib/armeabi-v7a/libnooshdaroo.so
# lib/x86_64/libnooshdaroo.so
```

#### Issue: VpnService permission denied

**Solution**: Request VPN permission before starting service:
```kotlin
val intent = VpnService.prepare(context)
if (intent != null) {
    startActivityForResult(intent, VPN_REQUEST_CODE)
}
```

#### Issue: VPN disconnects on screen off

**Solution**: Use foreground service and wake lock:
```kotlin
val wakeLock = powerManager.newWakeLock(
    PowerManager.PARTIAL_WAKE_LOCK,
    "NooshdarooVPN::WakeLock"
)
wakeLock.acquire(10*60*1000L)  // 10 minutes
```

### Common Issues (Both Platforms)

#### Issue: Connection fails with "Protocol error"

**Solution**: Verify server is using same protocol and compatible version

#### Issue: High battery drain

**Solution**: Optimize keep-alive intervals:
```rust
// In NooshdarooConfig
config.keepalive_interval = Duration::from_secs(60);  // Increase from 30s
```

#### Issue: Slow connection speed

**Solution**: Check MTU settings and disable traffic shaping for testing:
```rust
config.traffic_shaping = None;  // Disable for max throughput
```

---

## Next Steps

1. **Generate Real Server Keys**:
   ```bash
   cargo run --bin nooshdaroo -- genkey > server.key
   ```

2. **Update Embedded Keys**:
   ```bash
   export NOOSHDAROO_PRIMARY_KEY="<your_key_here>"
   ```

3. **Build Production Binaries**:
   ```bash
   ./build_ios.sh
   ./build_android.sh
   ```

4. **Deploy Server Infrastructure**:
   - See load balancer configurations in previous response
   - Deploy behind TCP Layer 4 load balancer
   - Use same server key across all backends

5. **Submit to App Stores**:
   - Follow App Store / Play Store guidelines above
   - Provide VPN disclosures and privacy policy

---

## References

- **Nooshdaroo Core**: `src/lib.rs`
- **Embedded Keys**: `src/embedded_keys.rs`
- **Protocol Wrapper**: `src/protocol_wrapper.rs`
- **Mobile Protocols**: `MOBILE_PROTOCOLS_READY.md`
- **Technical Reference**: `NOOSHDAROO_TECHNICAL_REFERENCE.md`
- **Noise Protocol**: https://noiseprotocol.org/
- **iOS Network Extension**: https://developer.apple.com/documentation/networkextension
- **Android VpnService**: https://developer.android.com/reference/android/net/VpnService

---

**Last Updated**: 2025-11-16
**Version**: 0.1.0
**Status**: Production Ready

# Dual-Transport DNS Tunnel Client Configuration
# Connects to server on port 53 using either UDP or TCP

mode = "client"

[socks]
# Local SOCKS5 proxy address
listen_addr = "127.0.0.1:1080"

# Remote server address (port 53 for DNS tunnel)
server_address = "example.com:53"

# Transport preference: "tcp", "udp", or "auto"
# - tcp: Use DNS-over-TCP (reliable, stateful)
# - udp: Use DNS queries (lower latency, stateless)
# - auto: Try UDP first, fallback to TCP on errors
transport_preference = "udp"

[transport]
# Noise Protocol pattern (must match server)
pattern = "nk"

# Server's public key (base64-encoded X25519 key)
# Get this from server's keygen output
remote_public_key = "INSERT_SERVER_PUBLIC_KEY_HERE"

# Client private key (only needed for KK pattern)
# local_private_key = "..."

[shapeshift]
# Protocol to emulate (must match server)
initial_protocol = "dns"

# Shape-shifting strategy (how often to rotate protocols)
# For DNS tunnel, typically keep same protocol
strategy = "static"

[detection]
# Enable TLS session emulation (only for HTTPS/TLS protocols)
enable_tls_session_emulation = false

[udp_client]
# Session ID (16-bit, randomly generated per connection)
# Leave blank for automatic random generation
# session_id = 0x1234

# Retry configuration for UDP
max_retries = 3
retry_timeout_ms = 1000

# Fallback to TCP after N failed UDP attempts
tcp_fallback_threshold = 3

[logging]
level = "debug"
format = "text"

# Example usage:
# 1. Get server's public key from server operator
#    Paste it into remote_public_key above
#
# 2. Run client:
#    nooshdaroo --config client-dns-dual.toml
#
# 3. Configure applications to use SOCKS5 proxy:
#    127.0.0.1:1080
#
# 4. Test with curl:
#    curl -x socks5h://127.0.0.1:1080 https://www.google.com
